
Installation Notes

Hardware
    The crude schematics in the doc subdirectory describe how to hook
    up the parts.  I assume if you're tackling this project that you
    can read between the lines in many cases.

    I prototyped the detector using an excellent breakout board
    (http://www.adafruit.com/products/296) from Adafruit Industries,
    which was great because of the USB connection and built-in
    bootloader.  The edit/compile/program/test cycle was extremely
    short, and I could install new code for the detector (which was
    outide at the meter) from the comfort of my living room armchair.

    That breakout board, even at just $20, felt like overkill for
    permanent installation.  Plus, I wasn't sure I wanted to run USB
    through the cellar wall.  Since I already had the ability to
    program smaller/cheaper AVR micros, and already owned some of the
    parts themselve, I ended up doing the final installation with an
    ATtiny44.  The tiny44 is hooked to an FTDI serial adapter from
    Sparkfun that I also already had -- otherwise the cost for the
    processor and serial adapter would have been right back in the $20
    ballpark.  Reprogramming got a lot harder on the tiny44, since I
    have to go outside, open the project box, pull the chip, go
    inside, program it, and then go out and reinstall.  But it feels
    more like real embedded programming, and that counts for
    something, right?

    (If you choose a different AVR processor, it will need an ADC
    input (which leaves out the ATtiny2313, unfortunately).  It also
    needs either USB, or currently, a 16-bit timer.  It's possible
    that the code in suart.c which implements the software uart could
    use an 8-bit timer if one were careful with multiplier scaling --
    then one could use an ATtiny45.)

    Physically, the the IR phototransistor peeks out of a hole drilled
    in a thin flat plastic project box that houses the tiny44 and the
    few other components.  The hole is positioned so that it sits just
    above the small cylindrical "light pipe" that brings the IR LED's
    pulses to the top of my electric meter.  See the pictures here: 
	http://irmetermon.sourceforge.net/pix.html
    
    I shaded the top of the electric meter by draping it with a piece
    of black sheet rubber.  Without this, the full sun my meter gets
    in the afternoon swamped the sensor, rendering the detector
    useless.

    (By the way, the project box I used came from digikey.com (part
    no.  HM377-ND).  I've used them in a couple of projects, because
    they look reasonable, are well made, easy to drill, etc, and cost
    less than $2.)

    (By the way #2 -- I used to program my AVR micros with a home-built
    parallel-port-based programmer, but I no longer have many convenient
    parallel ports.  So I got this USB-based one from Adafruit, and
    it works really well:  http://www.adafruit.com/products/46 )


Software

  AVR software
    Programming and working with the Atmel AVR microcontrollers is way
    beyond the scope of this file.  You'll need avr-gcc and friends,
    and probably avrdude to program your device.  If you're using a
    USB-capable AVR, you'll need the LUFA library as well
    (http://www.fourwalledcubicle.com/LUFA.php).  The AVR code can
    currently be built for either the ATmega32U4 ("make -f
    Makefile.lufa", or the ATtiny44 ("make -f Makefile.suart").

  Host software
    The program that talks to the device is read_ir.  It reformats the
    data, splits the debug info from the "good stuff", and emits the
    "good stuff" on its standard output.

    The program that logs the data is ir_meterlog.  It accepts
    formatted data generated by read_ir on its standard input, and
    generates processed power consumption logs in a configurable
    directory.  It also maintains a file called "watts_now", which
    contains a single number:  the instantaneous power consumption, in
    watts, calculated from the time between the more recent two
    pulses.  (As an aside, this is simple:  watts = 3600 / delta_t)
    
    The pipeline between read_ir and ir_meterlog is there partly to
    segregate functionality, but also so that data acquisition and
    data logging can be done on different machines -- something like
    netcat, for instance, could be easily used to extend that pipeline
    across the network.  I currently run read_ir and ir_meterlog on
    the same machine, using the "acquire" script, which i start from
    inittab, in order to make sure it's kept running.

    Both read_ir and ir_meterlog are built by the Makefile in the
    "host" subdirectory.  (So is "plotfix", which is described below.)

  Plotting
    The last piece is the plotting mechanism.  The script "power",
    found in the "plot" subdirectory, takes the accumulated logs and
    generates an index.html page that displays four images,
    corresponding to graphs of varying amounts of recent usage:  12
    hours, 36 hours, 1 week, and 2 hours.  (It displays the 2 hour
    plot last, since i mainly use it for debugging.  I find the 12
    hour plot most useful.)
    
    The graphs are generated using gnuplot -- the gnuplot
    configuration is in "power.plot".  The differences among the 4
    plots come from arguments passed to gnuplot as environment
    variables.  The power script massages the input data with a helper
    executable called "plotfix", whose job it is to fill in missing
    data points in the time-based logs.  Without this, gnuplot puts a
    continuous trace across gaps in the data, which is both ugly and
    misleading.  (plotfix fills gaps with a '0' value, which gnuplot
    is told represents missing data.)

    The power script will copy the resulting web page and graphs to a
    remote server, or to a local directory, or both.

    I invoke "power" from crontab, at one minute intervals.

    Currently, "make install" from the top-level directory will copy
    all the necessary binaries and scripts to a single directory,
    namely /usr/local/power.  This directory is also where I tell
    ir_meterlog to put the logs.  This is configurable, so that it's
    easy to put the dynamic data elsewhere.


Configuration
    The "acquire" and "power" scripts both set default values for many
    of their operational parameters, but those defaults can be easily
    overridden by setting values in a "config" file.  Both those
    scripts source the same "config" value, so it's easy to force them
    to agree on the location of the logs, for instance.  Other
    customizations (like the format of the graphs, or the generated
    web page) require editing the script(s).
